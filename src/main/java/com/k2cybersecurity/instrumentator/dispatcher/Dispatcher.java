package com.k2cybersecurity.instrumentator.dispatcher;

import com.k2cybersecurity.instrumentator.K2Instrumentator;
import com.k2cybersecurity.instrumentator.custom.ServletContextInfo;
import com.k2cybersecurity.instrumentator.utils.AgentUtils;
import com.k2cybersecurity.instrumentator.utils.CallbackUtils;
import com.k2cybersecurity.instrumentator.utils.HashGenerator;
import com.k2cybersecurity.intcodeagent.filelogging.FileLoggerThreadPool;
import com.k2cybersecurity.intcodeagent.filelogging.LogLevel;
import com.k2cybersecurity.intcodeagent.logging.DeployedApplication;
import com.k2cybersecurity.intcodeagent.logging.IAgentConstants;
import com.k2cybersecurity.intcodeagent.models.javaagent.*;
import com.k2cybersecurity.intcodeagent.models.operationalbean.*;
import com.k2cybersecurity.intcodeagent.websocket.EventSendPool;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.Nullable;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import java.io.File;
import java.io.ObjectInputStream;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;

import static com.k2cybersecurity.intcodeagent.logging.IAgentConstants.*;

/**
 * Agent utility for out of band processing and sending of events to K2 validator.
 */
public class Dispatcher implements Runnable {

    private static final String SEPARATOR_QUESTIONMARK = "?";
    private static final Pattern PATTERN;
    private static final FileLoggerThreadPool logger = FileLoggerThreadPool.getInstance();
    public static final String ERROR = "Error : ";
    public static final String EMPTY_FILE_SHA = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    public static final String DROPPING_APPLICATION_INFO_POSTING_DUE_TO_SIZE_0 = "Dropping application info posting due to size 0 : ";
    public static final String QUESTION_CHAR = SEPARATOR_QUESTIONMARK;
    //	public static final String SLASH = "/";
    public static final String FOR_NAME = "forName";
    public static final String SUN_REFLECT_COM_K_2_CYBERSECURITY_NET_BYTEBUDDY = "sun.reflect.com.k2cybersecurity.net.bytebuddy";
    public static final String PUBLIC_JAVA_LANG_STRING_JAVA_IO_FILE_LIST = "public java.lang.String[] java.io.File.list()";
    public static final String DROPPING_EVENT_AS_IT_WAS_GENERATED_BY_K_2_INTERNAL_API_CALL = "Dropping event as it was generated by K2 internal API call : ";
    public static final String CURRENT_GENERIC_SERVLET_INSTANCE = "currentGenericServletInstance";
    public static final String CURRENT_GENERIC_SERVLET_METHOD_NAME = "currentGenericServletMethodName";
    public static final String UPDATED_APPLICATION_INFO_POSTED = "[STEP-9][COMPLETE][APP_INFO][DEPLOYED_APP] Updated Application info sent to Prevent-Web service : %s";
    public static final char SEPARATOR = '.';
    public static final String INSIDE_SET_REQUIRED_STACK_TRACE = "Inside setRequiredStackTrace : ";
    private static final String APPLICATION_SERVER_DETECTION_COMPLETE = "[APP_INFO][DEPLOYED_APP] Deployed application info generated : %s";
    private static final String APPLICATION_SERVER_DETECTION_STARTED = "[STEP-9][BEGIN][APP_INFO][DEPLOYED_APP] Gathering deployed application info for current process.";
    private static final String EVENT_ZERO_SENT = "[STEP-8][COMPLETE][EVENT] First event sent for validation %s";
    private static final String SENDING_EVENT_ZERO = "[EVENT] Sending first event for validation.";
    private static final String POSTING_UPDATED_APPLICATION_INFO = "[APP_INFO][DEPLOYED_APP] Sending updated application info to Prevent-Web service : %s";


    private static final Object deployedAppDetectionLock = new Object();
    public static final String S_S = "%s-%s";
    public static final String K_2_SERVICE_NAME = "K2_SERVICE_NAME";
    public static final String SEPARATOR_COLON = ":";
    public static final String SETTING_UP_USER_PROVIDED_NAME = "Setting up user provided name : ";
    private ExitEventBean exitEventBean;
    private HttpRequestBean httpRequestBean;
    private AgentMetaData metaData;
    private Object event;
    private StackTraceElement[] trace;
    private VulnerabilityCaseType vulnerabilityCaseType;
    private Map<String, Object> extraInfo = new HashMap<String, Object>();
    private boolean isGeneratedByBuddy = false;
    private Class<?> currentGenericServletInstance;
    private String currentGenericServletMethodName = StringUtils.EMPTY;
    private UserClassEntity userClassEntity;
    private String apiID = StringUtils.EMPTY;
    private static AtomicBoolean firstEventSent = new AtomicBoolean(false);

    static {
        PATTERN = Pattern.compile(IAgentConstants.TRACE_REGEX);
    }

    public Dispatcher(HttpRequestBean httpRequestBean, AgentMetaData metaData, Object event,
                      VulnerabilityCaseType vulnerabilityCaseType) {
        this.httpRequestBean = httpRequestBean;
        this.metaData = metaData;
        this.event = event;
        this.vulnerabilityCaseType = vulnerabilityCaseType;
        extraInfo.put(BLOCKING_END_TIME, System.currentTimeMillis());
        currentGenericServletInstance = ((AbstractOperationalBean) event).getCurrentGenericServletInstance();
        currentGenericServletMethodName = ((AbstractOperationalBean) event).getCurrentGenericServletMethodName();
        trace = ((AbstractOperationalBean) event).getStackTrace();
        this.userClassEntity = ((AbstractOperationalBean) event).getUserClassEntity();
    }

    public Dispatcher(HttpRequestBean httpRequestBean, AgentMetaData metaData, Object event,
                      VulnerabilityCaseType vulnerabilityCaseType, String currentGenericServletMethodName,
                      Class<?> currentGenericServletInstance,
                      StackTraceElement[] stackTrace, UserClassEntity userClassEntity) {
        this.httpRequestBean = httpRequestBean;
        this.metaData = metaData;
        this.event = event;
        this.vulnerabilityCaseType = vulnerabilityCaseType;
        extraInfo.put(BLOCKING_END_TIME, System.currentTimeMillis());
        this.currentGenericServletInstance = currentGenericServletInstance;
        this.currentGenericServletMethodName = currentGenericServletMethodName;
        this.trace = stackTrace;
        this.userClassEntity = userClassEntity;
    }

    public Dispatcher(HttpRequestBean httpRequestBean, AgentMetaData agentMetaData, VulnerabilityCaseType reflectedXss,
                      String sourceString, String exectionId, long startTime, String currentGenericServletMethodName,
                      Class<?> currentGenericServletInstance,
                      StackTraceElement[] stackTrace, UserClassEntity userClassEntity, String apiID) {
        this.httpRequestBean = httpRequestBean;
        this.vulnerabilityCaseType = reflectedXss;
        this.metaData = agentMetaData;
        extraInfo.put(SOURCESTRING, sourceString);
        extraInfo.put(EXECUTIONID, exectionId);
        extraInfo.put(STARTTIME, startTime);
        extraInfo.put(BLOCKING_END_TIME, System.currentTimeMillis());

        this.currentGenericServletInstance = currentGenericServletInstance;
        this.currentGenericServletMethodName = currentGenericServletMethodName;
        this.trace = stackTrace;
        this.userClassEntity = userClassEntity;
        this.apiID = apiID;
    }

    public Dispatcher(ExitEventBean exitEventBean) {
        this.exitEventBean = exitEventBean;
    }


    /**
     * Processing of hooked data on the basis of case type.
     * Followed by delegated sending of event.
     */
    @Override
    public void run() {
        if (this.exitEventBean != null) {
            EventSendPool.getInstance().sendEvent(exitEventBean);
            return;
        }
        if(!firstEventSent.get()) {
            logger.logInit(LogLevel.INFO, SENDING_EVENT_ZERO, EventDispatcher.class.getName());
        }
        try {
            if (vulnerabilityCaseType.equals(VulnerabilityCaseType.REFLECTED_XSS)) {
                processReflectedXSSEvent();
                return;
            }
        } catch (Throwable e) {
            logger.log(LogLevel.ERROR, ERROR, e, Dispatcher.class.getName());
        }

        if (event == null) {
            // Invalid Event. Just drop.
            return;
        }

        JavaAgentEventBean eventBean = prepareEvent(httpRequestBean, metaData, vulnerabilityCaseType);

        switch (vulnerabilityCaseType) {
            case FILE_OPERATION:
                eventBean = processFileOperationEvent(eventBean);
                if (eventBean == null) {
                    return;
                }
                break;
            case SYSTEM_COMMAND:
                ForkExecOperationalBean operationalBean = (ForkExecOperationalBean) event;
                eventBean = setGenericProperties(operationalBean, eventBean);
                eventBean = prepareSystemCommandEvent(eventBean, operationalBean);
                break;
            case SYSTEM_EXIT:
                SystemExitOperationalBean systemExitOperationalBean = (SystemExitOperationalBean) event;
                eventBean = setGenericProperties(systemExitOperationalBean, eventBean);
                eventBean = prepareSystemExitEvent(eventBean, systemExitOperationalBean);

                break;
            case SQL_DB_COMMAND:
                List<SQLOperationalBean> operationalList = (List<SQLOperationalBean>) event;
                if (operationalList.isEmpty()) {
                    // Invalid Event. Just drop.
                    return;
                }
                eventBean = setGenericProperties(operationalList.get(0), eventBean);
                eventBean = prepareSQLDbCommandEvent(operationalList, eventBean);
                break;

            case NOSQL_DB_COMMAND:
                NoSQLOperationalBean noSQLOperationalBean = (NoSQLOperationalBean) event;
                eventBean = setGenericProperties(noSQLOperationalBean, eventBean);
                try {
                    eventBean = prepareNoSQLEvent(eventBean, noSQLOperationalBean);
                } catch (ParseException e) {
                    return;
                }
                break;

            case FILE_INTEGRITY:
                FileIntegrityBean fileIntegrityBean = (FileIntegrityBean) event;
                eventBean = setGenericProperties(fileIntegrityBean, eventBean);
                eventBean = prepareFileIntegrityEvent(eventBean, fileIntegrityBean);
                break;
            case LDAP:
                LDAPOperationalBean ldapOperationalBean = (LDAPOperationalBean) event;
                eventBean = setGenericProperties(ldapOperationalBean, eventBean);
                eventBean = prepareLDAPEvent(eventBean, ldapOperationalBean);
                break;
            case RANDOM:
                RandomOperationalBean randomOperationalBean = (RandomOperationalBean) event;
                eventBean = setGenericProperties(randomOperationalBean, eventBean);
                eventBean = prepareRandomEvent(eventBean, randomOperationalBean);
                break;
            case HTTP_REQUEST:
                SSRFOperationalBean ssrfOperationalBean = (SSRFOperationalBean) event;
                eventBean = setGenericProperties(ssrfOperationalBean, eventBean);
                eventBean = prepareSSRFEvent(eventBean, ssrfOperationalBean);
                break;
            case XPATH:
                XPathOperationalBean xPathOperationalBean = (XPathOperationalBean) event;
                eventBean = setGenericProperties(xPathOperationalBean, eventBean);
                eventBean = prepareXPATHEvent(eventBean, xPathOperationalBean);
                break;
            case SECURE_COOKIE:
                SecureCookieOperationalBean secureCookieOperationalBean = (SecureCookieOperationalBean) event;
                eventBean = setGenericProperties(secureCookieOperationalBean, eventBean);
                eventBean = prepareSecureCookieEvent(eventBean, secureCookieOperationalBean);
                break;
            case TRUSTBOUNDARY:
                TrustBoundaryOperationalBean trustBoundaryOperationalBean = (TrustBoundaryOperationalBean) event;
                eventBean = setGenericProperties(trustBoundaryOperationalBean, eventBean);
                eventBean = prepareTrustBoundaryEvent(eventBean, trustBoundaryOperationalBean);
                break;
            case CRYPTO:
                HashCryptoOperationalBean hashCryptoOperationalBean = (HashCryptoOperationalBean) event;
                eventBean = setGenericProperties(hashCryptoOperationalBean, eventBean);
                eventBean = prepareCryptoEvent(eventBean, hashCryptoOperationalBean);
                break;
            case HASH:
                HashCryptoOperationalBean hashOperationalBean = (HashCryptoOperationalBean) event;
                eventBean = setGenericProperties(hashOperationalBean, eventBean);
                eventBean = prepareHashEvent(eventBean, hashOperationalBean);
                break;
            case JAVASCRIPT_INJECTION:
                JSInjectionOperationalBean jsInjectionOperationalBean = (JSInjectionOperationalBean) event;
                eventBean = setGenericProperties(jsInjectionOperationalBean, eventBean);
                eventBean = prepareJSInjectionEvent(eventBean, jsInjectionOperationalBean);
                break;
            case XQUERY_INJECTION:
                XQueryOperationalBean xQueryOperationalBean = (XQueryOperationalBean) event;
                eventBean = setGenericProperties(xQueryOperationalBean, eventBean);
                eventBean = prepareXQueryInjectionEvent(eventBean, xQueryOperationalBean);
                break;
            default:

        }

        if (!VulnerabilityCaseType.FILE_INTEGRITY.equals(vulnerabilityCaseType)) {
            if (VulnerabilityCaseType.FILE_OPERATION.equals(vulnerabilityCaseType)
                    && ((FileOperationalBean) event).isGetBooleanAttributesCall()) {
                eventBean = processStackTrace(eventBean, vulnerabilityCaseType, false);
            } else {
                eventBean = processStackTrace(eventBean, vulnerabilityCaseType, true);
            }
            if (eventBean == null) {
                return;
            }
        }

        setRequiredStackRelatedInfoToEvent(eventBean);
        EventSendPool.getInstance().sendEvent(eventBean);
        if(!firstEventSent.get()) {
            logger.logInit(LogLevel.INFO, String.format(EVENT_ZERO_SENT, eventBean), EventDispatcher.class.getName());
            firstEventSent.set(true);
        }
        detectDeployedApplication();
    }

    @Nullable
    private JavaAgentEventBean processFileOperationEvent(JavaAgentEventBean eventBean) {
        FileOperationalBean fileOperationalBean = (FileOperationalBean) event;
        eventBean = setGenericProperties(fileOperationalBean, eventBean);
        eventBean = prepareFileEvent(eventBean, fileOperationalBean);
        String URL = StringUtils.substringBefore(httpRequestBean.getUrl(), QUESTION_CHAR);
        if (!(AgentUtils.getInstance().getAgentPolicy().getVulnerabilityScan().getEnabled()
                && AgentUtils.getInstance().getAgentPolicy().getVulnerabilityScan().getIastScan().getEnabled()) && allowedExtensionFileIO(eventBean.getParameters(), eventBean.getSourceMethod(), URL)) {
            // Event is bypassed. Drop it.
            return null;
        }
        return eventBean;
    }


    /**
     * Validate and send if required event for REFLECTED XSS
     */
    private void processReflectedXSSEvent() {
        Set<String> xssConstructs = CallbackUtils.checkForReflectedXSS(httpRequestBean);
        JavaAgentEventBean eventBean = prepareEvent(httpRequestBean, metaData, vulnerabilityCaseType);
        if (K2Instrumentator.APPLICATION_INFO_BEAN.getServerInfo().getDeployedApplications().isEmpty() ||
                (!xssConstructs.isEmpty() && !actuallyEmpty(xssConstructs) && StringUtils.isNotBlank(httpRequestBean.getHttpResponseBean().getResponseBody())) ||
                (AgentUtils.getInstance().getAgentPolicy().getVulnerabilityScan().getEnabled()
                        && AgentUtils.getInstance().getAgentPolicy().getVulnerabilityScan().getIastScan().getEnabled())) {
            JSONArray params = new JSONArray();
            params.addAll(xssConstructs);
            params.add(httpRequestBean.getHttpResponseBean().getResponseBody());
            eventBean.setParameters(params);
            eventBean.setApplicationUUID(K2Instrumentator.APPLICATION_UUID);
            eventBean.setPid(K2Instrumentator.VMPID);
            eventBean.setSourceMethod((String) extraInfo.get(SOURCESTRING));
            eventBean.setId((String) extraInfo.get(EXECUTIONID));
            eventBean.setStartTime((Long) extraInfo.get(STARTTIME));
            eventBean.setBlockingProcessingTime(
                    (Long) extraInfo.get(BLOCKING_END_TIME) - eventBean.getStartTime());

            eventBean.setUserAPIInfo(userClassEntity.getUserClassElement().getLineNumber(),
                    userClassEntity.getUserClassElement().getClassName(),
                    userClassEntity.getUserClassElement().getMethodName());

            eventBean.setApiId(apiID);

            setRequiredStackRelatedInfoToEvent(eventBean);
            EventSendPool.getInstance().sendEvent(eventBean);
            if(!firstEventSent.get()) {
                logger.logInit(LogLevel.INFO, String.format(EVENT_ZERO_SENT, eventBean), EventDispatcher.class.getName());
                firstEventSent.set(true);
            }
            detectDeployedApplication();
        }
    }

    private boolean actuallyEmpty(Set<String> xssConstructs) {
        for (String xssConstruct : xssConstructs) {
            if (StringUtils.isNotBlank(xssConstruct)) {
                return false;
            }
        }
        return true;
    }

    private void detectDeployedApplication() {
        if (userClassEntity.isCalledByUserCode() && httpRequestBean.getServerPort() > 0) {
            DeployedApplication deployedApplication = new DeployedApplication();
            deployedApplication.getPorts().add(httpRequestBean.getServerPort());
            deployedApplication.setContextPath(httpRequestBean.getContextPath());
            if (!K2Instrumentator.APPLICATION_INFO_BEAN.getServerInfo().getDeployedApplications().contains(deployedApplication)
                    && !AgentUtils.getInstance().getDeployedApplicationUnderProcessing().contains(deployedApplication)) {
                AgentUtils.getInstance().getDeployedApplicationUnderProcessing().add(deployedApplication);
                detectAndSendDeployedAppInfo(deployedApplication);
            }
        }
    }

    private void setRequiredStackRelatedInfoToEvent(JavaAgentEventBean eventBean) {
        try {
//            stackPreProcess(eventBean);
            int fromLoc = 0;
            int toLoc = this.trace.length;
//		logger.log(LogLevel.DEBUG, INSIDE_SET_REQUIRED_STACK_TRACE + eventBean.getId() + STRING_COLON + JsonConverter.toJSON(userClassEntity) + STRING_COLON + JsonConverter.toJSON(Arrays.asList(trace)), Dispatcher.class.getName());
            if (metaData != null && metaData.isK2FuzzRequest()) {
                if (StringUtils.equals(eventBean.getHttpRequest().getK2RequestIdentifierInstance().getApiRecordId(), eventBean.getApiId()) && StringUtils.equals(eventBean.getHttpRequest().getK2RequestIdentifierInstance().getNextStage().getStatus(), IAgentConstants.VULNERABLE)) {
                    eventBean.setCompleteStacktrace(Arrays.asList(trace).subList(0, Math.min(trace.length, 120)));
                }
                return;
            }

            if (AgentUtils.getInstance().getAgentPolicy().getSendCompleteStackTrace()) {
                eventBean.setStacktrace(Arrays.asList(trace).subList(0, Math.min(trace.length, 120)));
                return;
            }

            if (userClassEntity.isCalledByUserCode()) {
                toLoc = userClassEntity.getTraceLocationEnd();
                String packageName = getMatchPackagePrefix(userClassEntity.getUserClassElement().getClassName());
                if (StringUtils.isBlank(packageName)) {
                    setFiniteSizeStackTrace(eventBean);
                } else {
                    int i = toLoc;
                    for (i = toLoc; i >= 0; i--) {
                        if (!StringUtils.startsWith(trace[i].getClassName(), packageName)) {
                            break;
                        }
                    }
                    fromLoc = i;
                    int delta = toLoc - fromLoc;
                    if (delta < 5) {
                        if (fromLoc >= delta) {
                            // decrease from fromLoc
                            fromLoc -= delta;
                        } else {
                            // decrease from fromLoc & increase in toLoc
                            delta = delta - fromLoc;
                            fromLoc = 0;

                            if (trace.length - 1 >= toLoc + delta) {
                                toLoc += delta;
                            } else {
                                toLoc = trace.length - 1;
                            }
                        }
                    }
//				logger.log(LogLevel.DEBUG, "Setting setRequiredStackTracePart by auto detect : " + eventBean.getId(), Dispatcher.class.getName());
                    eventBean.setStacktrace(Arrays.asList(Arrays.copyOfRange(this.trace, Math.max(fromLoc, 0),
                            Math.min(toLoc + 2, trace.length))));
                }
            } else {
                setFiniteSizeStackTrace(eventBean);
            }
        } catch (Exception e) {
            logger.log(LogLevel.ERROR, ERROR, e, Dispatcher.class.getName());
        }
    }

    private void setFiniteSizeStackTrace(JavaAgentEventBean eventBean) {
//		logger.log(LogLevel.DEBUG, "Setting setFiniteSizeStackTrace : " + eventBean.getId(), Dispatcher.class.getName());
        int fromLoc = 0;
        int toLoc = this.trace.length;
        fromLoc = Math.max(userClassEntity.getTraceLocationEnd() - 4, 0);
        toLoc = Math.min(userClassEntity.getTraceLocationEnd() + 2, trace.length);
        eventBean.setStacktrace(Arrays.asList(Arrays.copyOfRange(this.trace, fromLoc, toLoc)));
    }

    private String getMatchPackagePrefix(String className) {
        String[] parts = StringUtils.split(className, SEPARATOR);
        if (parts.length == 1) {
            return StringUtils.EMPTY;
        }
        if (parts.length > 2) {
            return StringUtils.join(parts, SEPARATOR, 0, 2);
        } else {
            return StringUtils.join(parts, SEPARATOR, 0, parts.length - 1);
        }

    }

    private boolean detectAndSendDeployedAppInfo(DeployedApplication deployedApplication) {
        logger.logInit(
                LogLevel.INFO,
                APPLICATION_SERVER_DETECTION_STARTED,
                Dispatcher.class.getName()
        );
        try {
            if (K2Instrumentator.APPLICATION_INFO_BEAN.getServerInfo().getDeployedApplications()
                    .contains(deployedApplication)) {
                return false;
            }
            logger.log(LogLevel.INFO, "Creating new deployed application", Dispatcher.class.getName());
            deployedApplication.setDeployedPath(AgentUtils.getInstance().detectDeployedApplicationPath(
                    userClassEntity.getUserClassElement().getClassName(), currentGenericServletInstance,
                    userClassEntity.getUserClassElement().getMethodName()));
            logger.log(LogLevel.INFO, "Deployed app after set path : " + deployedApplication, Dispatcher.class.getName());
            boolean ret = false;
            try {
                ret = ServletContextInfo.getInstance().processServletContext(httpRequestBean, deployedApplication);
                logger.log(LogLevel.INFO, "Deployed app after processing : " + deployedApplication + " :: " + ret, Dispatcher.class.getName());
                HashGenerator.updateShaAndSize(deployedApplication);
                logger.log(LogLevel.INFO, "Deployed app after processing 1 : " + deployedApplication + " :: " + ret, Dispatcher.class.getName());
            } catch (Throwable e) {
                logger.log(LogLevel.ERROR, "Error while deployed app processing : " + deployedApplication, e, Dispatcher.class.getName());
            }

            if (deployedApplication.isEmpty() ||
                    StringUtils.isBlank(deployedApplication.getSha256()) ||
                    StringUtils.equals(deployedApplication.getSha256(), EMPTY_FILE_SHA)) {
                logger.log(LogLevel.ERROR, DROPPING_APPLICATION_INFO_POSTING_DUE_TO_SIZE_0 + deployedApplication,
                        Dispatcher.class.getName());
                return false;
            }

//			System.out.println("Processed App Info : " + deployedApplication);
            ApplicationInfoBean applicationInfoBean = K2Instrumentator.APPLICATION_INFO_BEAN;

            applicationInfoBean.getServerInfo().setName(ServletContextInfo.getInstance().getServerInfo());
            logger.logInit(
                    LogLevel.INFO,
                    String.format(APPLICATION_SERVER_DETECTION_COMPLETE, applicationInfoBean),
                    Dispatcher.class.getName()
            );
            K2Instrumentator.JA_HEALTH_CHECK.setProtectedServer(ServletContextInfo.getInstance().getServerInfo());

            if (applicationInfoBean.getServerInfo().getDeployedApplications().add(deployedApplication)) {
                logger.logInit(
                        LogLevel.INFO,
                        String.format(POSTING_UPDATED_APPLICATION_INFO, applicationInfoBean),
                        Dispatcher.class.getName()
                );
                EventSendPool.getInstance().sendEvent(applicationInfoBean.toString());
                logger.logInit(LogLevel.INFO,
                        String.format(UPDATED_APPLICATION_INFO_POSTED, applicationInfoBean),
                        Dispatcher.class.getName());
//				EventSendPool.getInstance().sendEvent(scanComponentData.toString());
            }
//				System.out.println("============= AppInfo Start ============");
//				System.out.println(applicationInfoBean);
//				System.out.println("============= AppInfo End ============");

            return true;
        } finally {
            AgentUtils.getInstance().getDeployedApplicationUnderProcessing().remove(deployedApplication);
        }
    }


    private JavaAgentEventBean prepareJSInjectionEvent(JavaAgentEventBean eventBean,
                                                       JSInjectionOperationalBean jsInjectionOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(jsInjectionOperationalBean.getJavaScriptCode());
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareXQueryInjectionEvent(JavaAgentEventBean eventBean,
                                                           XQueryOperationalBean xQueryOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(xQueryOperationalBean.getExpression());
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareSystemExitEvent(JavaAgentEventBean eventBean,
                                                      SystemExitOperationalBean systemExitOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(systemExitOperationalBean.getExitCode());
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareXPATHEvent(JavaAgentEventBean eventBean,
                                                 XPathOperationalBean xPathOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(xPathOperationalBean.getExpression());
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareHashEvent(JavaAgentEventBean eventBean,
                                                HashCryptoOperationalBean hashOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(hashOperationalBean.getName());
        if (StringUtils.isNotBlank(hashOperationalBean.getProvider())) {
            params.add(hashOperationalBean.getProvider());
        }
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareCryptoEvent(JavaAgentEventBean eventBean,
                                                  HashCryptoOperationalBean hashCryptoOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(hashCryptoOperationalBean.getName());
        if (StringUtils.isNotBlank(hashCryptoOperationalBean.getProvider())) {
            params.add(hashCryptoOperationalBean.getProvider());
        }
        eventBean.setParameters(params);
        if (eventBean.getSourceMethod().equals(JAVAX_CRYPTO_CIPHER_GETINSTANCE_STRING)
                || eventBean.getSourceMethod().equals(JAVAX_CRYPTO_CIPHER_GETINSTANCE_STRING_PROVIDER)) {
            eventBean.setEventCategory(CIPHER);
        } else if (eventBean.getSourceMethod().equals(JAVAX_CRYPTO_KEYGENERATOR_GETINSTANCE_STRING)
                || eventBean.getSourceMethod().equals(JAVAX_CRYPTO_KEYGENERATOR_GETINSTANCE_STRING_STRING)
                || eventBean.getSourceMethod().equals(JAVAX_CRYPTO_KEYGENERATOR_GETINSTANCE_STRING_PROVIDER)) {
            eventBean.setEventCategory(KEYGENERATOR);
        } else if (eventBean.getSourceMethod().equals(JAVA_SECURITY_KEYPAIRGENERATOR_GETINSTANCE_STRING)
                || eventBean.getSourceMethod().equals(JAVA_SECURITY_KEYPAIRGENERATOR_GETINSTANCE_STRING_STRING)
                || eventBean.getSourceMethod().equals(JAVA_SECURITY_KEYPAIRGENERATOR_GETINSTANCE_STRING_PROVIDER)) {
            eventBean.setEventCategory(KEYPAIRGENERATOR);
        }
        return eventBean;
    }

    private JavaAgentEventBean prepareTrustBoundaryEvent(JavaAgentEventBean eventBean,
                                                         TrustBoundaryOperationalBean trustBoundaryOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(trustBoundaryOperationalBean.getKey());
        params.add(trustBoundaryOperationalBean.getValue());
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareRandomEvent(JavaAgentEventBean eventBean,
                                                  RandomOperationalBean randomOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(randomOperationalBean.getClassName());
        eventBean.setEventCategory(randomOperationalBean.getEventCatgory());
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareSecureCookieEvent(JavaAgentEventBean eventBean,
                                                        SecureCookieOperationalBean secureCookieOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(secureCookieOperationalBean.getValue());
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareLDAPEvent(JavaAgentEventBean eventBean, LDAPOperationalBean ldapOperationalBean) {
        JSONArray params = new JSONArray();
        JSONObject object = new JSONObject();
        object.put(NAME, ldapOperationalBean.getName());
        object.put(FILTER, ldapOperationalBean.getFilter());
        params.add(object);
        eventBean.setParameters(params);
        return eventBean;
    }

    private JavaAgentEventBean prepareFileIntegrityEvent(JavaAgentEventBean eventBean,
                                                         FileIntegrityBean fileIntegrityBean) {
        JSONArray params = new JSONArray();
        params.add(fileIntegrityBean.getFileName());
        eventBean.setParameters(params);
//		eventBean.setUserAPIInfo(fileIntegrityBean.getLineNumber(), fileIntegrityBean.getClassName(),
//				fileIntegrityBean.getUserMethodName());
        eventBean.setUserAPIInfo(userClassEntity.getUserClassElement().getLineNumber(),
                userClassEntity.getUserClassElement().getClassName(),
                userClassEntity.getUserClassElement().getMethodName());
        eventBean.setCurrentMethod(fileIntegrityBean.getCurrentMethod());
        return eventBean;
    }

    private void createEntryForFileIntegrity(FileOperationalBean fileOperationalBean, JavaAgentEventBean eventBean) {
        FileIntegrityBean fBean = (FileIntegrityBean) extraInfo.get(FILEINTEGRITYBEAN);
        if (fBean != null) {
            fBean.setBeanValues(eventBean.getSourceMethod(), eventBean.getUserFileName(), eventBean.getUserMethodName(),
                    eventBean.getCurrentMethod(), eventBean.getLineNumber());
        }
    }

    private JavaAgentEventBean prepareSQLDbCommandEvent(List<SQLOperationalBean> operationalList,
                                                        JavaAgentEventBean eventBean) {
        JSONArray params = new JSONArray();
        for (SQLOperationalBean operationalBean : operationalList) {
            JSONObject query = new JSONObject();
            query.put(QUERY, operationalBean.getQuery());
            query.put(PARAMETERS, new JSONObject(operationalBean.getParams()));
            params.add(query);
        }
        eventBean.setParameters(params);
        eventBean.setEventCategory(operationalList.get(0).getDbName());
        return eventBean;
    }

    private JavaAgentEventBean prepareSystemCommandEvent(JavaAgentEventBean eventBean,
                                                         ForkExecOperationalBean operationalBean) {
        JSONArray params = new JSONArray();
        params.add(operationalBean.getCommand());
        if (operationalBean.getEnvironment() != null) {
            params.add(new JSONObject(operationalBean.getEnvironment()));
        }
        eventBean.setParameters(params);
        return eventBean;
    }

    private static JavaAgentEventBean prepareFileEvent(JavaAgentEventBean eventBean,
                                                       FileOperationalBean fileOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(fileOperationalBean.getFileName());
        eventBean.setParameters(params);
        return eventBean;
    }

    private static JavaAgentEventBean prepareNoSQLEvent(JavaAgentEventBean eventBean,
                                                        NoSQLOperationalBean noSQLOperationalBean) throws ParseException {
        JSONArray params = new JSONArray();
        eventBean.setEventCategory(MONGO);
        JSONParser jsonParser = new JSONParser();
        params.addAll((JSONArray) jsonParser.parse(noSQLOperationalBean.getData().toString()));
        eventBean.setParameters(params);
        K2Instrumentator.JA_HEALTH_CHECK.getProtectedDB().add(MONGO);
        return eventBean;
    }

    private static JavaAgentEventBean prepareSSRFEvent(JavaAgentEventBean eventBean,
                                                       SSRFOperationalBean ssrfOperationalBean) {
        JSONArray params = new JSONArray();
        params.add(ssrfOperationalBean.getArg());
        eventBean.setParameters(params);
        if (ssrfOperationalBean.isJNDILookup()) {
            eventBean.setEventCategory("JNDILookup");
        }
        return eventBean;
    }

//	private static JavaAgentEventBean prepareSSRFEvent(JavaAgentEventBean eventBean,
//			SSRFOperationalBean ssrfOperationalBean) {
//		JSONArray params = new JSONArray();
//		String sourceString = eventBean.getSourceMethod();
//		Object[] obj = ssrfOperationalBean.getApiCallArgs();
//
//		if (sourceString.equals(JAVA_OPEN_CONNECTION_METHOD2) || sourceString.equals(JAVA_OPEN_CONNECTION_METHOD2_HTTPS)
//				|| sourceString.equals(JAVA_OPEN_CONNECTION_METHOD2_HTTPS_2)
//				|| sourceString.equals(WEBLOGIC_OPEN_CONNECTION_METHOD)) {
//			ProcessorThread.getJavaHttpRequestParameters(obj, params);
//		} else if (sourceString.equals(JDK_INCUBATOR_MULTIEXCHANGE_RESONSE_METHOD)
//				|| sourceString.equals(JDK_INCUBATOR_MULTIEXCHANGE_RESONSE_ASYNC_METHOD)) {
//			ProcessorThread.getJava9HttpClientParameters(obj, params);
//		} else if (sourceString.equals(APACHE_HTTP_REQUEST_EXECUTOR_METHOD)) {
//			ProcessorThread.getApacheHttpRequestParameters(obj, params);
//		} else if (sourceString.equals(APACHE_COMMONS_HTTP_METHOD_DIRECTOR_METHOD)) {
//			ProcessorThread.getApacheCommonsHttpRequestParameters(obj, params);
//		} else if (sourceString.equals(OKHTTP_HTTP_ENGINE_METHOD)) {
//			ProcessorThread.getOkHttpRequestParameters(obj, params);
//		}
//
//		eventBean.setParameters(params);
//		return eventBean;
//	}

    private boolean allowedExtensionFileIO(JSONArray params, String sourceString, String url) {
        if (JAVA_IO_FILE_INPUTSTREAM_OPEN.equals(sourceString)) {
            for (int i = 0; i < params.size(); i++) {
                String filePath = params.get(i).toString();

                if (StringUtils.containsIgnoreCase(filePath, File.separator)) {
                    filePath = StringUtils.substringAfterLast(filePath, File.separator);
                }

                if (StringUtils.containsIgnoreCase(url, File.separator)) {
                    url = StringUtils.substringAfterLast(url, File.separator);
                }

                if (StringUtils.equals(url, filePath))
                    return true;
            }
        }
        return false;
    }

    private JavaAgentEventBean processStackTrace(JavaAgentEventBean eventBean,
                                                 VulnerabilityCaseType vulnerabilityCaseType, boolean deserialisationCheck) {

        String klassName = null;
        String[] traceData = new String[trace.length];

        for (int i = trace.length - 1; i >= 0; i--) {
            traceData[i] = AgentUtils.stackTraceElementToString(trace[i]);
        }

        for (int i = 0; i < traceData.length; i++) {
            // TODO : check this sequence. Why this is being set from inside Deserialisation check.
            if (isGeneratedByBuddy) {
                logger.log(LogLevel.DEBUG, DROPPING_EVENT_AS_IT_WAS_GENERATED_BY_K_2_INTERNAL_API_CALL + eventBean,
                        Dispatcher.class.getName());
                return null;
            }
            klassName = trace[i].getClassName();
            if (VulnerabilityCaseType.SYSTEM_COMMAND.equals(vulnerabilityCaseType)
                    || VulnerabilityCaseType.SQL_DB_COMMAND.equals(vulnerabilityCaseType)
                    || VulnerabilityCaseType.FILE_INTEGRITY.equals(vulnerabilityCaseType)
                    || VulnerabilityCaseType.NOSQL_DB_COMMAND.equals(vulnerabilityCaseType)
                    || VulnerabilityCaseType.FILE_OPERATION.equals(vulnerabilityCaseType)
                    || VulnerabilityCaseType.HTTP_REQUEST.equals(vulnerabilityCaseType)
                    || VulnerabilityCaseType.SYSTEM_EXIT.equals(vulnerabilityCaseType)) {
                rciTriggerCheck(i, eventBean, klassName, traceData);
                xxeTriggerCheck(i, eventBean, klassName, traceData);
                if (deserialisationCheck) {
                    deserializationTriggerCheck(i, eventBean, klassName);
                }
            }
        }
        eventBean.setUserAPIInfo(userClassEntity.getUserClassElement().getLineNumber(),
                userClassEntity.getUserClassElement().getClassName(),
                userClassEntity.getUserClassElement().getMethodName());
        return eventBean;
    }

    private void xxeTriggerCheck(int i, JavaAgentEventBean eventBean, String klassName, String[] traceData) {

        if ((StringUtils.contains(klassName, XML_DOCUMENT_FRAGMENT_SCANNER_IMPL)
                && StringUtils.equals(trace[i].getMethodName(), SCAN_DOCUMENT))
                || (StringUtils.contains(klassName, XML_ENTITY_MANAGER)
                && StringUtils.equals(trace[i].getMethodName(), SETUP_CURRENT_ENTITY))) {
            eventBean.getMetaData().setTriggerViaXXE(true);
            logger.log(LogLevel.DEBUG,
                    String.format(PRINTING_STACK_TRACE_FOR_XXE_EVENT_S_S, eventBean.getId(), Arrays.asList(traceData)),
                    Dispatcher.class.getName());
        }
    }

    private void deserializationTriggerCheck(int index, JavaAgentEventBean eventBean, String klassName) {
        if (ObjectInputStream.class.getName().equals(klassName)
                && StringUtils.equals(trace[index].getMethodName(), READ_OBJECT)) {
            eventBean.getMetaData().setTriggerViaDeserialisation(true);
//				JSONArray jsonArray = new JSONArray();
//				jsonArray.addAll(Arrays.asList(trace));
//				eventBean.setStacktrace(jsonArray);
//				logger.log(LogLevel.DEBUG, String.format(PRINTING_STACK_TRACE_FOR_DESERIALISE_EVENT_S_S,
//						eventBean.getId(), Arrays.asList(trace)), Dispatcher.class.getName());
        }

        if (StringUtils.startsWith(klassName, SUN_REFLECT_COM_K_2_CYBERSECURITY_NET_BYTEBUDDY)) {
            isGeneratedByBuddy = true;
        }
    }

    private void rciTriggerCheck(int index, JavaAgentEventBean eventBean, String klassName, String[] traceData) {
        if (!StringUtils.contains(traceData[index], DOT_JAVA_COLON) && index > 0
                && StringUtils.contains(traceData[index - 1], DOT_JAVA_COLON)) {
            eventBean.getMetaData().setTriggerViaRCI(true);
            eventBean.getMetaData().getRciMethodsCalls().add(traceData[index]);
            eventBean.getMetaData().getRciMethodsCalls().add(traceData[index - 1]);
//			logger.log(LogLevel.DEBUG, String.format(PRINTING_STACK_TRACE_FOR_PROBABLE_RCI_EVENT_S_S,
//					eventBean.getId(), Arrays.asList(trace)), Dispatcher.class.getName());
        }
        if (StringUtils.contains(klassName, REFLECT_NATIVE_METHOD_ACCESSOR_IMPL)
                && StringUtils.equals(trace[index].getMethodName(), INVOKE_0) && index > 0) {
            eventBean.getMetaData().setTriggerViaRCI(true);
            eventBean.getMetaData().getRciMethodsCalls().add(traceData[index - 1]);
//			logger.log(LogLevel.DEBUG, String.format(PRINTING_STACK_TRACE_FOR_RCI_EVENT_S_S, eventBean.getId(),
//					Arrays.asList(trace)), Dispatcher.class.getName());
        }
    }

    private JavaAgentEventBean setGenericProperties(AbstractOperationalBean objectBean, JavaAgentEventBean eventBean) {
        eventBean.setApplicationUUID(K2Instrumentator.APPLICATION_UUID);
        eventBean.setPid(K2Instrumentator.VMPID);
        eventBean.setSourceMethod(objectBean.getSourceMethod());
        eventBean.setId(objectBean.getExecutionId());
        eventBean.setStartTime(objectBean.getStartTime());
        eventBean.setBlockingProcessingTime((Long) extraInfo.get(BLOCKING_END_TIME) - eventBean.getStartTime());
        eventBean.setApiId(objectBean.getApiID());
        return eventBean;
    }

    private JavaAgentEventBean prepareEvent(HttpRequestBean httpRequestBean, AgentMetaData metaData,
                                            VulnerabilityCaseType vulnerabilityCaseType) {
        JavaAgentEventBean eventBean = new JavaAgentEventBean();
        eventBean.setHttpRequest(httpRequestBean);
        eventBean.setMetaData(metaData);
        eventBean.setCaseType(vulnerabilityCaseType.getCaseType());
        eventBean.setIsAPIBlocked(metaData.isApiBlocked());
        if (AgentUtils.getInstance().getAgentPolicy().getVulnerabilityScan().getEnabled() && AgentUtils.getInstance().getAgentPolicy().getVulnerabilityScan().getIastScan().getEnabled()) {
            eventBean.setIsIASTEnable(true);
        }
        return eventBean;
    }

    public static String getDbName(String className) {
        if (StringUtils.contains(className, MSSQL_DB_IDENTIFIER))
            return MSSQL;
        else if (StringUtils.contains(className, MYSQL_DB_IDENTIFIER))
            return MYSQL;
        else if (StringUtils.contains(className, HSQL_DB_IDENTIFIER))
            return HSQL;
        else if (StringUtils.contains(className, POSTGRESQL_DB_IDENTIFIER))
            return POSTGRESQL;
        else if (StringUtils.contains(className, FIREBIRD_DB_IDENTIFIER))
            return FIREBIRD;
        else if (StringUtils.contains(className, H2_DB_IDENTIFIER))
            return H2;
        else if (StringUtils.contains(className, DERBY_DB_IDENTIFIER))
            return DERBY;
        else if (StringUtils.contains(className, IBMDB2_DB_IDENTIFIER))
            return IBMDB2;
        else if (StringUtils.contains(className, TERADATA_DB_IDENTIFIER))
            return TERADATA;
        else if (StringUtils.contains(className, ORACLE_DB_IDENTIFIER))
            return ORACLE;
        else if (StringUtils.contains(className, MARIADB_DB_IDENTIFIER))
            return MARIADB;
        else
            return UNKNOWN;

    }

    public void printDispatch() {
        try {
            logger.log(LogLevel.DEBUG,
                    "==========================================================================================",
                    Dispatcher.class.getName());

            logger.log(LogLevel.DEBUG, "Intercepted Request : " + httpRequestBean, Dispatcher.class.getName());

            logger.log(LogLevel.DEBUG, "Intercepted Response : " + httpRequestBean.getHttpResponseBean(),
                    Dispatcher.class.getName());

            logger.log(LogLevel.DEBUG, "Agent Meta : " + metaData, Dispatcher.class.getName());

            logger.log(LogLevel.DEBUG, "Intercepted transaction : " + event, Dispatcher.class.getName());

            logger.log(LogLevel.DEBUG, "Trace : " + Arrays.asList(trace), Dispatcher.class.getName());

            logger.log(LogLevel.DEBUG, "vulnerabilityCaseType : " + vulnerabilityCaseType, Dispatcher.class.getName());

            logger.log(LogLevel.DEBUG,
                    "==========================================================================================",
                    Dispatcher.class.getName());
        } catch (Throwable e) {
        }
    }

}